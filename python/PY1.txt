import pandas as pd
import numpy as np
import talib
from datetime import datetime, timedelta
import pytz
import time
import logging
from typing import Dict, List, Optional, Tuple
import json

# SmartAPI imports
from smartapi import SmartConnect
from smartapi.smartWebSocketV2 import SmartWebSocketV2

class IntradayTradingStrategy:
    def __init__(self, config: Dict):
        """
        Initialize the intraday trading strategy
        
        Args:
            config: Dictionary containing API credentials and strategy parameters
        """
        # API Configuration
        self.api_key = config.get('api_key')
        self.username = config.get('username')
        self.pwd = config.get('pwd')
        self.smartapi = None
        self.auth_token = None
        self.feed_token = None
        
        # Strategy Configuration
        self.symbol = config.get('symbol', 'RELIANCE-EQ')
        self.token = config.get('token')  # Trading symbol token
        self.lot_size = config.get('lot_size', 1)
        self.capital = config.get('capital', 100000)
        
        # Session Configuration
        self.session_start = config.get('session_start', '09:15')
        self.session_end = config.get('session_end', '15:15')
        self.exit_before_close = config.get('exit_before_close', 30)  # minutes
        
        # Strategy Parameters
        self.use_supertrend = config.get('use_supertrend', True)
        self.use_vwap = config.get('use_vwap', False)
        self.use_ema_crossover = config.get('use_ema_crossover', True)
        self.use_volume_filter = config.get('use_volume_filter', True)
        self.use_time_filter = config.get('use_time_filter', True)
        self.use_gap_filter = config.get('use_gap_filter', True)
        self.use_rsi_filter = config.get('use_rsi_filter', True)
        
        # Technical Indicators Parameters
        self.atr_length = config.get('atr_length', 10)
        self.atr_multiplier = config.get('atr_multiplier', 3.0)
        self.fast_ema = config.get('fast_ema', 9)
        self.slow_ema = config.get('slow_ema', 21)
        self.rsi_length = config.get('rsi_length', 14)
        self.rsi_overbought = config.get('rsi_overbought', 70)
        self.rsi_oversold = config.get('rsi_oversold', 30)
        
        # Exit Parameters
        self.use_tiered_tp = config.get('use_tiered_tp', True)
        self.tp1_points = config.get('tp1_points', 50)
        self.tp2_points = config.get('tp2_points', 100)
        self.tp3_points = config.get('tp3_points', 200)
        self.base_sl_points = config.get('base_sl_points', 30)
        self.atr_stop_mult = config.get('atr_stop_mult', 1.5)
        self.trail_tightness = config.get('trail_tightness', 1.0)
        
        # Power Hours
        self.power_hour1 = (config.get('power_hour1_start', 9), config.get('power_hour1_end', 11))
        self.power_hour2 = (config.get('power_hour2_start', 14), config.get('power_hour2_end', 15))
        
        # Filter Parameters
        self.volume_threshold = config.get('volume_threshold', 1.5)
        self.gap_threshold = config.get('gap_threshold', 0.5)
        
        # Trading State
        self.position = {
            'size': 0,
            'entry_price': 0,
            'entry_time': None,
            'tp1_filled': False,
            'tp2_filled': False,
            'trailing_active': False
        }
        
        self.data_buffer = pd.DataFrame()
        self.last_exit_reason = ""
        self.last_exit_time = None
        self.is_session_active = False
        
        # Setup logging
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
        
        # IST timezone
        self.ist = pytz.timezone('Asia/Kolkata')
        
    def authenticate(self):
        """Authenticate with SmartAPI"""
        try:
            self.smartapi = SmartConnect(api_key=self.api_key)
            data = self.smartapi.generateSession(self.username, self.pwd)
            
            if data['status']:
                self.auth_token = data['data']['jwtToken']
                self.feed_token = self.smartapi.getfeedToken()
                self.logger.info("Authentication successful")
                return True
            else:
                self.logger.error(f"Authentication failed: {data}")
                return False
                
        except Exception as e:
            self.logger.error(f"Authentication error: {e}")
            return False
    
    def get_historical_data(self, interval: str = "ONE_MINUTE", days: int = 5) -> pd.DataFrame:
        """Get historical data for analysis"""
        try:
            from_date = (datetime.now() - timedelta(days=days)).strftime("%Y-%m-%d %H:%M")
            to_date = datetime.now().strftime("%Y-%m-%d %H:%M")
            
            params = {
                "exchange": "NSE",
                "symboltoken": self.token,
                "interval": interval,
                "fromdate": from_date,
                "todate": to_date
            }
            
            data = self.smartapi.getCandleData(params)
            
            if data['status']:
                df = pd.DataFrame(data['data'], columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
                df['timestamp'] = pd.to_datetime(df['timestamp'])
                df.set_index('timestamp', inplace=True)
                
                # Convert to numeric
                for col in ['open', 'high', 'low', 'close', 'volume']:
                    df[col] = pd.to_numeric(df[col])
                    
                return df
            else:
                self.logger.error(f"Failed to get historical data: {data}")
                return pd.DataFrame()
                
        except Exception as e:
            self.logger.error(f"Error getting historical data: {e}")
            return pd.DataFrame()
    
    def calculate_supertrend(self, df: pd.DataFrame) -> pd.DataFrame:
        """Calculate Supertrend indicator"""
        try:
            high = df['high'].values
            low = df['low'].values
            close = df['close'].values
            
            # Calculate ATR
            atr = talib.ATR(high, low, close, timeperiod=self.atr_length)
            
            # Calculate basic upper and lower bands
            hl2 = (high + low) / 2
            upper_band = hl2 + (self.atr_multiplier * atr)
            lower_band = hl2 - (self.atr_multiplier * atr)
            
            # Initialize arrays
            supertrend = np.zeros(len(df))
            direction = np.ones(len(df))
            
            for i in range(1, len(df)):
                # Upper band calculation
                if upper_band[i] < upper_band[i-1] or close[i-1] > upper_band[i-1]:
                    upper_band[i] = upper_band[i]
                else:
                    upper_band[i] = upper_band[i-1]
                
                # Lower band calculation  
                if lower_band[i] > lower_band[i-1] or close[i-1] < lower_band[i-1]:
                    lower_band[i] = lower_band[i]
                else:
                    lower_band[i] = lower_band[i-1]
                
                # Determine direction
                if close[i] <= lower_band[i]:
                    direction[i] = -1
                elif close[i] >= upper_band[i]:
                    direction[i] = 1
                else:
                    direction[i] = direction[i-1]
                
                # Set Supertrend value
                if direction[i] == 1:
                    supertrend[i] = lower_band[i]
                else:
                    supertrend[i] = upper_band[i]
            
            df['supertrend'] = supertrend
            df['supertrend_direction'] = direction
            
            return df
            
        except Exception as e:
            self.logger.error(f"Error calculating Supertrend: {e}")
            return df
    
    def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """Calculate all technical indicators"""
        try:
            if len(df) < 50:  # Need sufficient data
                return df
            
            # Basic indicators
            df['ema_fast'] = talib.EMA(df['close'].values, timeperiod=self.fast_ema)
            df['ema_slow'] = talib.EMA(df['close'].values, timeperiod=self.slow_ema)
            df['rsi'] = talib.RSI(df['close'].values, timeperiod=self.rsi_length)
            df['atr'] = talib.ATR(df['high'].values, df['low'].values, df['close'].values, timeperiod=self.atr_length)
            
            # VWAP calculation
            df['typical_price'] = (df['high'] + df['low'] + df['close']) / 3
            df['volume_price'] = df['typical_price'] * df['volume']
            df['vwap'] = df['volume_price'].rolling(window=len(df)).sum() / df['volume'].rolling(window=len(df)).sum()
            
            # Supertrend
            df = self.calculate_supertrend(df)
            
            # Volume filter
            df['volume_avg'] = df['volume'].rolling(window=20).mean()
            
            # Momentum
            df['momentum'] = df['close'].pct_change(5) * 100
            
            return df
            
        except Exception as e:
            self.logger.error(f"Error calculating indicators: {e}")
            return df
    
    def check_session_time(self) -> Tuple[bool, bool, int]:
        """Check if current time is within trading session"""
        now = datetime.now(self.ist)
        current_time = now.time()
        
        # Parse session times
        start_time = datetime.strptime(self.session_start, '%H:%M').time()
        end_time = datetime.strptime(self.session_end, '%H:%M').time()
        
        # Check if in session
        in_session = start_time <= current_time <= end_time
        
        # Calculate minutes to session end
        end_datetime = datetime.combine(now.date(), end_time)
        current_datetime = datetime.combine(now.date(), current_time)
        minutes_to_end = (end_datetime - current_datetime).total_seconds() / 60
        
        # Check if should force exit
        should_exit = in_session and minutes_to_end <= self.exit_before_close
        
        return in_session, should_exit, int(minutes_to_end)
    
    def check_power_hours(self) -> bool:
        """Check if current time is in power hours"""
        if not self.use_time_filter:
            return True
            
        now = datetime.now(self.ist)
        current_hour = now.hour
        
        # Power hour 1
        if self.power_hour1[0] <= current_hour < self.power_hour1[1]:
            return True
        
        # Power hour 2  
        if self.power_hour2[0] <= current_hour < self.power_hour2[1]:
            return True
            
        return False
    
    def check_gap_filter(self, df: pd.DataFrame) -> bool:
        """Check gap filter condition"""
        if not self.use_gap_filter or len(df) < 2:
            return True
            
        try:
            # Get previous day's close (assuming daily data is available)
            current_open = df['open'].iloc[-1]
            prev_close = df['close'].iloc[-2]  # Previous bar close as proxy
            
            gap_percent = abs(current_open - prev_close) / prev_close * 100
            
            if gap_percent > self.gap_threshold:
                # Only trade gap ups for long strategy
                return current_open > prev_close
            
            return True
            
        except Exception as e:
            self.logger.error(f"Error in gap filter: {e}")
            return True
    
    def generate_signals(self, df: pd.DataFrame) -> Dict:
        """Generate trading signals based on strategy logic"""
        if len(df) < 50:
            return {'buy': False, 'signal_strength': 0, 'filters_passed': []}
        
        latest = df.iloc[-1]
        signals = {'buy': False, 'signal_strength': 0, 'filters_passed': []}
        
        try:
            # Technical signals
            supertrend_bullish = self.use_supertrend and latest['supertrend_direction'] == 1
            vwap_bullish = not self.use_vwap or latest['close'] > latest['vwap']
            
            # EMA crossover (check if fast EMA crossed above slow EMA recently)
            ema_bullish = True
            if self.use_ema_crossover and len(df) >= 2:
                prev = df.iloc[-2]
                ema_bullish = (latest['ema_fast'] > latest['ema_slow'] and 
                              prev['ema_fast'] <= prev['ema_slow'])
            
            # Filters
            volume_filter = (not self.use_volume_filter or 
                           latest['volume'] > latest['volume_avg'] * self.volume_threshold)
            
            time_filter = self.check_power_hours()
            
            gap_filter = self.check_gap_filter(df)
            
            rsi_filter = (not self.use_rsi_filter or 
                         (latest['rsi'] > self.rsi_oversold and latest['rsi'] < self.rsi_overbought))
            
            # Calculate signal strength
            signal_count = sum([
                supertrend_bullish,
                vwap_bullish, 
                ema_bullish,
                volume_filter,
                time_filter,
                gap_filter,
                rsi_filter
            ])
            
            # Generate buy signal
            buy_signal = (supertrend_bullish and vwap_bullish and ema_bullish and 
                         volume_filter and time_filter and gap_filter and rsi_filter)
            
            signals = {
                'buy': buy_signal,
                'signal_strength': signal_count,
                'filters_passed': {
                    'supertrend': supertrend_bullish,
                    'vwap': vwap_bullish,
                    'ema_crossover': ema_bullish,
                    'volume': volume_filter,
                    'time': time_filter,
                    'gap': gap_filter,
                    'rsi': rsi_filter
                }
            }
            
        except Exception as e:
            self.logger.error(f"Error generating signals: {e}")
            
        return signals
    
    def place_order(self, transaction_type: str, quantity: int, price: float = None, 
                   order_type: str = "MARKET", product: str = "MIS") -> Dict:
        """Place order via SmartAPI"""
        try:
            order_params = {
                "variety": "NORMAL",
                "tradingsymbol": self.symbol,
                "symboltoken": self.token,
                "transactiontype": transaction_type,
                "exchange": "NSE",
                "ordertype": order_type,
                "producttype": product,
                "duration": "DAY",
                "quantity": str(quantity)
            }
            
            if price and order_type != "MARKET":
                order_params["price"] = str(price)
            
            response = self.smartapi.placeOrder(order_params)
            
            if response['status']:
                self.logger.info(f"Order placed successfully: {response}")
                return response
            else:
                self.logger.error(f"Order placement failed: {response}")
                return response
                
        except Exception as e:
            self.logger.error(f"Error placing order: {e}")
            return {'status': False, 'message': str(e)}
    
    def calculate_position_size(self, current_price: float) -> int:
        """Calculate position size based on capital and risk management"""
        try:
            # Use fixed percentage of capital for position sizing
            risk_per_trade = 0.02  # 2% risk per trade
            stop_loss_points = max(self.base_sl_points, 
                                 self.atr_stop_mult * self.data_buffer['atr'].iloc[-1] if len(self.data_buffer) > 0 else self.base_sl_points)
            
            # Calculate quantity based on risk
            risk_amount = self.capital * risk_per_trade
            quantity = int(risk_amount / stop_loss_points)
            
            # Ensure minimum lot size
            return max(quantity, self.lot_size)
            
        except Exception as e:
            self.logger.error(f"Error calculating position size: {e}")
            return self.lot_size
    
    def manage_position(self, current_price: float, df: pd.DataFrame):
        """Manage existing position with tiered exits"""
        if self.position['size'] == 0:
            return
            
        try:
            entry_price = self.position['entry_price']
            current_points = (current_price - entry_price)
            
            # Check for stop loss
            atr_value = df['atr'].iloc[-1] if len(df) > 0 else 20
            stop_loss_points = max(self.base_sl_points, self.atr_stop_mult * atr_value)
            
            if current_points <= -stop_loss_points:
                self.close_position("Stop Loss Hit")
                return
            
            # Tiered take profits
            if self.use_tiered_tp:
                # TP1 - 50% exit
                if not self.position['tp1_filled'] and current_points >= self.tp1_points:
                    quantity_to_close = self.position['size'] // 2
                    if quantity_to_close > 0:
                        self.place_order("SELL", quantity_to_close)
                        self.position['size'] -= quantity_to_close
                        self.position['tp1_filled'] = True
                        self.logger.info(f"TP1 hit - Closed {quantity_to_close} shares")
                
                # TP2 - 30% of remaining
                if (self.position['tp1_filled'] and not self.position['tp2_filled'] and 
                    current_points >= self.tp2_points):
                    quantity_to_close = max(1, int(self.position['size'] * 0.6))
                    if quantity_to_close > 0:
                        self.place_order("SELL", quantity_to_close)
                        self.position['size'] -= quantity_to_close
                        self.position['tp2_filled'] = True
                        self.logger.info(f"TP2 hit - Closed {quantity_to_close} shares")
                
                # TP3 - Final exit
                if (self.position['tp2_filled'] and current_points >= self.tp3_points):
                    self.close_position("TP3 - Final Target")
                    return
            
            # Check for momentum weakening (simplified)
            if len(df) >= 6:
                current_momentum = df['momentum'].iloc[-1]
                past_momentum = df['momentum'].iloc[-6]
                
                if (self.position['tp1_filled'] and current_momentum < past_momentum and 
                    current_momentum < 0):
                    # Close remaining position due to momentum weakness
                    self.close_position("Momentum Weakening")
                    
        except Exception as e:
            self.logger.error(f"Error managing position: {e}")
    
    def close_position(self, reason: str):
        """Close entire position"""
        if self.position['size'] > 0:
            try:
                response = self.place_order("SELL", self.position['size'])
                if response.get('status'):
                    self.logger.info(f"Position closed: {reason}")
                    self.last_exit_reason = reason
                    self.last_exit_time = datetime.now(self.ist)
                    
                    # Reset position
                    self.position = {
                        'size': 0,
                        'entry_price': 0,
                        'entry_time': None,
                        'tp1_filled': False,
                        'tp2_filled': False,
                        'trailing_active': False
                    }
                    
            except Exception as e:
                self.logger.error(f"Error closing position: {e}")
    
    def can_reenter(self) -> bool:
        """Check if re-entry is allowed based on last exit"""
        if not self.last_exit_time:
            return True
            
        time_since_exit = (datetime.now(self.ist) - self.last_exit_time).total_seconds() / 60
        
        # Different re-entry rules based on exit reason
        if self.last_exit_reason == "Stop Loss Hit":
            return time_since_exit >= 15  # Wait 15 minutes after stop loss
        elif self.last_exit_reason in ["TP1 - Final Target", "TP2 - Final Target", "TP3 - Final Target"]:
            return time_since_exit >= 10  # Wait 10 minutes after profit taking
        elif "Time Exit" in self.last_exit_reason:
            return False  # No re-entry after time-based exit
        else:
            return time_since_exit >= 5  # Default 5 minute wait
    
    def run_strategy(self):
        """Main strategy execution loop"""
        self.logger.info("Starting intraday trading strategy...")
        
        if not self.authenticate():
            self.logger.error("Failed to authenticate. Exiting.")
            return
        
        while True:
            try:
                # Check session time
                in_session, should_exit, minutes_to_end = self.check_session_time()
                
                if not in_session:
                    if self.is_session_active:
                        self.logger.info("Session ended")
                        self.is_session_active = False
                    time.sleep(60)  # Wait 1 minute before checking again
                    continue
                
                self.is_session_active = True
                
                # Force exit if close to session end
                if should_exit and self.position['size'] > 0:
                    self.close_position(f"Time Exit - {minutes_to_end} minutes to close")
                    continue
                
                # Get fresh data
                df = self.get_historical_data()
                if df.empty:
                    self.logger.warning("No data received")
                    time.sleep(30)
                    continue
                
                # Calculate indicators
                df = self.calculate_indicators(df)
                self.data_buffer = df.copy()
                
                current_price = df['close'].iloc[-1]
                
                # Manage existing position
                if self.position['size'] > 0:
                    self.manage_position(current_price, df)
                
                # Check for new entry signals
                elif minutes_to_end > (self.exit_before_close + 30):  # Don't enter too close to session end
                    signals = self.generate_signals(df)
                    
                    if signals['buy'] and self.can_reenter():
                        quantity = self.calculate_position_size(current_price)
                        
                        response = self.place_order("BUY", quantity)
                        if response.get('status'):
                            self.position = {
                                'size': quantity,
                                'entry_price': current_price,
                                'entry_time': datetime.now(self.ist),
                                'tp1_filled': False,
                                'tp2_filled': False,
                                'trailing_active': False
                            }
                            
                            self.logger.info(f"Entry signal taken: {quantity} shares at {current_price}")
                            self.logger.info(f"Signal strength: {signals['signal_strength']}")
                
                # Sleep before next iteration
                time.sleep(30)  # Check every 30 seconds
                
            except KeyboardInterrupt:
                self.logger.info("Strategy stopped by user")
                if self.position['size'] > 0:
                    self.close_position("Manual Stop")
                break
                
            except Exception as e:
                self.logger.error(f"Error in main loop: {e}")
                time.sleep(60)  # Wait 1 minute before retrying

# Configuration example
if __name__ == "__main__":
    config = {
        # API Credentials (Replace with your actual credentials)
        'api_key': 'your_api_key',
        'username': 'your_username', 
        'pwd': 'your_password',
        
        # Trading Parameters
        'symbol': 'RELIANCE-EQ',
        'token': '738561',  # RELIANCE token - replace with actual
        'lot_size': 1,
        'capital': 100000,
        
        # Session Times
        'session_start': '09:15',
        'session_end': '15:15',
        'exit_before_close': 30,
        
        # Strategy Toggles
        'use_supertrend': True,
        'use_vwap': False,
        'use_ema_crossover': True,
        'use_volume_filter': True,
        'use_time_filter': True,
        'use_gap_filter': True,
        'use_rsi_filter': True,
        
        # Technical Parameters
        'atr_length': 10,
        'atr_multiplier': 3.0,
        'fast_ema': 9,
        'slow_ema': 21,
        'rsi_length': 14,
        'rsi_overbought': 70,
        'rsi_oversold': 30,
        
        # Exit Parameters
        'use_tiered_tp': True,
        'tp1_points': 50,
        'tp2_points': 100,
        'tp3_points': 200,
        'base_sl_points': 30,
        'atr_stop_mult': 1.5,
        
        # Power Hours
        'power_hour1_start': 9,
        'power_hour1_end': 11,
        'power_hour2_start': 14,
        'power_hour2_end': 15,
        
        # Filters
        'volume_threshold': 1.5,
        'gap_threshold': 0.5
    }
    
    # Initialize and run strategy
    strategy = IntradayTradingStrategy(config)
    strategy.run_strategy()